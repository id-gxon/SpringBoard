# Database
	- DB 생성, 계정 생성, 테이블 설계(ERD), 테이블 더미 데이터 생성

# SpringMVC
	- 패키지 구조 설계, 개발 환경 구성(빌드도구 - MAVEN), 컨트롤러, 서비스, DAO 구조 설계, 테스트 파일 생성

# View
	뷰 페이지 형태 설정

	# 컨트롤러 설계 #
		- 공통적인 URI의 경로 / 각 기능별 URI 경로
		- 각 URI의 호출 방법(GET/POST)
		- 각 기능별 결과 처리(View 출력, Redirect)
		- 예외 페이지
		
		= 컨트롤러를 구분하는 기준은 도메인 객체(DB Table)
		
		* 공통 URI	: /board or /boards
		* 호출 방식	: GET - 사용자 정보 입력, 조회, 출력
					  POST - 데이터를 처리(insert, update, delete)
		* 기능별 URI: 글쓰기GET - /board/register
					  글쓰기POST - /board/register
					  리스트GET - /board/list
					  본문읽기GET - /board/read?bno=000
					  본문수정GET - /board/modify?bno=000
					  본문수정POST - /board/modify
					  본문삭제POST - /board/remove?bno=000
	
	# 의존객체 자동주입 #
		- 스프링(컨테이너)이 자동으로 의존관계에 있는 객체를 사용하도록 의존성을 주입하는 것
		
		* @Inject: Java에서 지원하는 어노테이션(특정 프레임워크에 종속적이지 않음)
			
			- 의존객체를 찾는 순서
				[타입] -> [@Qualifier] -> [이름] -> 실패
				
			- 빌드도구(Maven / Gradle)를 사용해서 라이브러리 의존성 추가 필요
			- 멤버 변수, Setter, 생성자, 일반 메서드 사용 가능
		
		* @Autowired: Spring에서 지원하는 어노테이션
			
			- 의존객체를 찾는 순서
				[타입] -> [이름] -> [@Qualifier] -> 실패
			
			- @Inject와 찾는 순서만 다를 뿐 동일하게 동작
			- <context:annotation-config/> 구문 설정 필요
			- 멤버변수, Setter, 생성자, 일반 메서드 사용 가능
		
		* @Resource: Java에서 지원하는 어노테이션
		
			- 의존객체를 찾는 순서
				[이름] -> [타입] -> [@Qualifier] -> 실패
			
			- <context:annotation-config/> 구문 설정 필요
			- 멤버변수, Setter 사용 가능
		
		** @Qualifier
			1) 객체를 주입 받아올 때 동일한 객체(bean)가 있을 경우 예외 발생
			2) 특정 객체를 구분하기 위한 이름(별명)
			
			ex)	<bean id="dataSource1"class="com.zaxxer.hizari.HikariDataSource">
					<qualifier value="ds1"/>
				</bean>
				<bean id="dataSource2" class="com.zaxxer.hizari.HikariDataSource">
					<qualifier value="ds2"/>
				</bean>
				
				@Inject / @Autowired	@Qualifier("ds2")
				private DataSource ds;
				
				-------------------------------------------------------------------
				
				// 생성자를 사용한 객체 주입
				private DataSource ds;
				
				public Test(DataSource ds) {
					this.ds = ds;
				}
				
				= 순환 참조를 막을 수 있어 권장(Test와 유지보수에 유리)
		

* p.83
	커넥션 풀: DB 연결 정보를 미리 생성 / 대여
	-> HikariCP - 스프링 부트에서도 사용(성능, 지속성 보장)


* Project package 구조
	- 계층형 구조: 각각의 객체 별로 따로 관리(Controller, Service, Persistence)
		장점: 프로젝트에 대한 이해도가 낮음 -> 구조 파악이 쉬움
		단점: 클래스가 많아지면 복잡, 모듈 별로 분리가 어려움
		
		= 프로젝트의 복잡도가 낮고, 기능이 적은 경우
		= 기능을 특정 기준을 바탕으로 구분하기 어려운 경우
		= 해당 기능을 별도의 모듈로 분리할 가능성이 없는 경우
	
	- 도메인형 구조: 도메인을 중심으로 따로 관리(Member.Controller, Member.Service, Member.Persistence)
		장점: 모듈 별로 구분이 쉬움(분리가 쉬움)
		단점: 프로젝트에 대한 이해도가 낮으면, 구조 파악이 힘듦, 개인적인 성향에 따른 구분(기준이 모호)
			* 패키지 간의 순환 참조의 가능성 존재
		
		= 프로젝트의 복잡도가 높고, 하나의 계층에 포함되는 클래스가 많은 경우
		= 기능 별로 명확한 구분이 가능한 경우
		= 추후에 별도로 모듈 분리가 가능한 경우
		
* @ModelAttribute vs @RequestParam
	-@ModelAttribute: 파라메터 저장 + 영역 저장(1:N 관계)
	-@RequestParam	: 파라메터 저장(1:1 관계)